# TODO - January 3rd, 2026

## Payments & Analytics

- [ ] **1. Install Stripe Payments**
  - Setup subscription sign-up flow for users
  - Configure Stripe products and pricing plans
  - Implement checkout session creation
  - Handle webhook events for subscription lifecycle
  - Add subscription status to user profile


### ðŸŽ¯ Stripe Integration Implementation Guide

#### Backend Setup

##### 1. Environment Variables

Add these to your `.env.local`:

```bash
# Stripe API Keys
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_EXPLORER_PASS_PRICE_ID=price_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

Get these from your [Stripe Dashboard](https://dashboard.stripe.com):
- **Secret Key**: Settings â†’ API Keys â†’ Secret Key
- **Publishable Key**: Settings â†’ API Keys â†’ Publishable Key
- **Price ID**: Products â†’ Select Product â†’ Copy Price ID
- **Webhook Secret**: Webhooks â†’ Signing Secret

##### 2. Database Schema

Your `User` model should include these Stripe fields:

```prisma
model User {
  id                      String
  email                   String
  name                    String?

  // Stripe fields
  stripeCustomerId        String?     @unique
  stripeSubscriptionId    String?
  stripePriceId           String?
  stripeCurrentPeriodEnd  DateTime?
  subscriptionStatus      String?     // 'active', 'trialing', 'past_due', 'canceled'
}
```

#### Backend API Endpoints

##### 1. Create Checkout Session

**Endpoint:** `POST /api/stripe/create-checkout-session`

**Authentication:** Required (JWT token via cookie or Authorization header)

**Request Body:**
```json
{
  "successUrl": "https://yourapp.com/dashboard?session_id={CHECKOUT_SESSION_ID}",
  "cancelUrl": "https://yourapp.com/pricing"
}
```

**Response:**
```json
{
  "success": true,
  "sessionId": "cs_test_...",
  "url": "https://checkout.stripe.com/pay/cs_test_..."
}
```

**Error Responses:**
- `401 Unauthorized`: Missing or invalid authentication token
- `400 Bad Request`: Missing `successUrl` or `cancelUrl`
- `500 Internal Server Error`: Stripe configuration or API error

##### 2. Create Billing Portal Session

**Endpoint:** `POST /api/stripe/create-portal-session`

**Authentication:** Required (JWT token via cookie or Authorization header)

**Request Body:**
```json
{
  "returnUrl": "https://yourapp.com/dashboard"
}
```

**Response:**
```json
{
  "success": true,
  "url": "https://billing.stripe.com/session/..."
}
```

##### 3. Get Subscription Status

**Endpoint:** `GET /api/stripe/subscription`

**Authentication:** Required (JWT token via cookie or Authorization header)

**Response:**
```json
{
  "success": true,
  "subscription": {
    "stripeCustomerId": "cus_...",
    "stripeSubscriptionId": "sub_...",
    "stripePriceId": "price_...",
    "stripeCurrentPeriodEnd": "2025-02-03T12:00:00Z",
    "subscriptionStatus": "active",
    "isActive": true
  }
}
```

#### Frontend Implementation

##### 1. Install Dependencies

```bash
npm install @stripe/stripe-js
```

##### 2. Environment Variables

Add to your frontend `.env.local`:

```bash
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
NEXT_PUBLIC_API_URL=http://localhost:3001
```

##### 3. Create Stripe Hook

Create `src/hooks/useStripe.ts`:

```typescript
'use client';

import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!
);

export const useStripe = () => {
  /**
   * Create a checkout session and redirect to Stripe
   */
  const createCheckoutSession = async (
    successUrl: string,
    cancelUrl: string
  ) => {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/stripe/create-checkout-session`,
        {
          method: 'POST',
          credentials: 'include', // â† IMPORTANT: Send cookies with JWT token
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            successUrl,
            cancelUrl,
          }),
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to create checkout session');
      }

      const { url } = await response.json();

      // Redirect to Stripe Checkout
      if (url) {
        window.location.href = url;
      }
    } catch (error) {
      console.error('Checkout error:', error);
      throw error;
    }
  };

  /**
   * Open Stripe Billing Portal for subscription management
   */
  const openBillingPortal = async (returnUrl: string) => {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/stripe/create-portal-session`,
        {
          method: 'POST',
          credentials: 'include', // â† IMPORTANT: Send cookies with JWT token
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            returnUrl,
          }),
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to open billing portal');
      }

      const { url } = await response.json();

      // Redirect to Stripe Billing Portal
      if (url) {
        window.location.href = url;
      }
    } catch (error) {
      console.error('Billing portal error:', error);
      throw error;
    }
  };

  /**
   * Get current subscription status
   */
  const getSubscriptionStatus = async () => {
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/stripe/subscription`,
        {
          method: 'GET',
          credentials: 'include', // â† IMPORTANT: Send cookies with JWT token
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to get subscription status');
      }

      const { subscription } = await response.json();
      return subscription;
    } catch (error) {
      console.error('Subscription status error:', error);
      throw error;
    }
  };

  return {
    createCheckoutSession,
    openBillingPortal,
    getSubscriptionStatus,
  };
};
```

##### 4. Subscribe Button Component

Create `src/components/SubscribeButton.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@mui/material';
import { useStripe } from '@/hooks/useStripe';

interface SubscribeButtonProps {
  planName: string;
  disabled?: boolean;
}

export const SubscribeButton = ({ planName, disabled = false }: SubscribeButtonProps) => {
  const { createCheckoutSession } = useStripe();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubscribe = async () => {
    setLoading(true);
    setError(null);

    try {
      const currentUrl = window.location.origin;

      await createCheckoutSession(
        `${currentUrl}/dashboard?session_id={CHECKOUT_SESSION_ID}`,
        `${currentUrl}/pricing`
      );
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to start checkout';
      setError(message);
      console.error('Checkout error:', err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Button
        variant="contained"
        color="primary"
        onClick={handleSubscribe}
        disabled={loading || disabled}
        fullWidth
      >
        {loading ? 'Loading...' : `Subscribe to ${planName}`}
      </Button>
      {error && (
        <div style={{ color: 'red', marginTop: '8px', fontSize: '14px' }}>
          {error}
        </div>
      )}
    </>
  );
};
```

##### 5. Manage Subscription Component

Create `src/components/ManageSubscription.tsx`:

```typescript
'use client';

import { useEffect, useState } from 'react';
import { Box, Button, Typography, CircularProgress } from '@mui/material';
import { useStripe } from '@/hooks/useStripe';

export const ManageSubscription = () => {
  const { getSubscriptionStatus, openBillingPortal } = useStripe();
  const [subscription, setSubscription] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchSubscription = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await getSubscriptionStatus();
        setSubscription(data);
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load subscription';
        setError(message);
      } finally {
        setLoading(false);
      }
    };

    fetchSubscription();
  }, [getSubscriptionStatus]);

  const handleManageSubscription = async () => {
    try {
      await openBillingPortal(window.location.origin + '/dashboard');
    } catch (err) {
      console.error('Failed to open billing portal:', err);
    }
  };

  if (loading) {
    return <CircularProgress />;
  }

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  if (!subscription?.isActive) {
    return (
      <Typography>
        No active subscription. Visit the pricing page to subscribe.
      </Typography>
    );
  }

  return (
    <Box sx={{ padding: 2, border: '1px solid #ddd', borderRadius: 1 }}>
      <Typography variant="h6">Subscription Status</Typography>
      <Typography>Status: {subscription.subscriptionStatus}</Typography>
      <Typography>
        Renews: {new Date(subscription.stripeCurrentPeriodEnd).toLocaleDateString()}
      </Typography>
      <Button
        variant="outlined"
        onClick={handleManageSubscription}
        sx={{ marginTop: 2 }}
      >
        Manage Subscription
      </Button>
    </Box>
  );
};
```

##### 6. Add to Your App

```tsx
import { SubscribeButton } from '@/components/SubscribeButton';
import { ManageSubscription } from '@/components/ManageSubscription';

export default function PricingPage() {
  return (
    <div>
      <h1>Pricing Plans</h1>
      <SubscribeButton planName="Explorer Pass" />
      <ManageSubscription />
    </div>
  );
}
```

#### Authentication Details

The Stripe endpoints require JWT authentication. Your frontend must send the JWT token with each request:

**Option 1: Using Cookies (Recommended)**
```typescript
credentials: 'include' // Automatically sends the 'token' cookie
```

**Option 2: Using Authorization Header**
```typescript
headers: {
  'Authorization': `Bearer ${token}`
}
```

The backend's `authenticateToken` middleware will:
1. Extract the token from the `Authorization` header or `token` cookie
2. Verify the JWT signature
3. Extract the `userId` from the token
4. Attach the user to the request object

#### Complete Subscription Flow

1. **User clicks "Subscribe"** â†’ Frontend calls `createCheckoutSession(successUrl, cancelUrl)`
2. **Frontend sends authenticated request** â†’ Includes JWT token via cookies or header
3. **Backend validates authentication** â†’ Extracts `userId` from JWT token
4. **Backend creates Stripe session** â†’ Gets or creates Stripe customer, returns session URL
5. **Frontend redirects to Stripe** â†’ User completes payment on Stripe
6. **Stripe webhook updates database** â†’ Webhook handler receives `checkout.session.completed` event
7. **User redirected back to app** â†’ Success URL includes session ID for verification

#### Error Handling

| Error | Cause | Solution |
|-------|-------|----------|
| `401 Unauthorized` | Missing/invalid JWT token | Ensure user is logged in and token is sent with request |
| `400 Bad Request` | Missing `successUrl` or `cancelUrl` | Provide both URLs in request body |
| `No Stripe customer found` | User has no Stripe customer ID | Backend will auto-create one on first checkout |
| `STRIPE_SECRET_KEY is not set` | Missing environment variable | Add `STRIPE_SECRET_KEY` to `.env.local` |

#### Testing

Use these test card numbers in Stripe Checkout:

| Card | Number | Expiry | CVC |
|------|--------|--------|-----|
| Success | `4242 4242 4242 4242` | Any future date | Any 3 digits |
| Decline | `4000 0000 0000 0002` | Any future date | Any 3 digits |
| Requires Auth | `4000 0025 0000 3155` | Any future date | Any 3 digits |

#### Security Checklist

- âœ… **JWT tokens** are verified on every request
- âœ… **HTTP-only cookies** prevent XSS attacks
- âœ… **User ID extracted from token** (not from request body)
- âœ… **Stripe webhook signature verified** before processing
- âœ… **Environment variables** for sensitive keys
- âœ… **CORS configured** for frontend domain
- âœ… **Error messages** don't leak sensitive information

#### Troubleshooting

**"Failed to create checkout session"**
1. Check browser console for detailed error
2. Verify JWT token is being sent (check Network tab in DevTools)
3. Verify `STRIPE_SECRET_KEY` is set in backend
4. Verify `STRIPE_EXPLORER_PASS_PRICE_ID` is set in backend

**"No Stripe customer found"**
- This is normal on first checkout. The backend will automatically create a Stripe customer.

**Webhook not updating database**
1. Verify `STRIPE_WEBHOOK_SECRET` is correct
2. Check server logs for webhook errors
3. Verify webhook endpoint is registered in Stripe Dashboard
4. Ensure webhook is sending to correct URL


- [ ] **2. Setup PostHog Analytics**
  - Install PostHog SDK in frontend
  - Configure event tracking for key user actions
  - Setup session recording (optional)
  - Create funnels for onboarding and conversion tracking
  - Configure feature flags for A/B testing

## Onboarding

- [ ] **3. Setup Onboarding v1**
  - Design onboarding flow screens
  - Implement step-by-step tutorial for new users
  - Create first Focus wizard
  - Add tooltips for key interface elements
  - Track onboarding completion state

- [ ] **4. Add Metrics for Onboarding**
  - Track traffic sources (referrals, direct, organic)
  - Measure conversion rates at each onboarding step
  - Track sign-up completions
  - Create dashboard for onboarding analytics
  - Setup alerts for conversion drop-offs

## v3 Interface - Core Features

- [ ] **5. Update Snackbar with Mini Hexagon Node**
  - Add Mini Hexagon Node as left image in Snackbar
  - Make the hexagon node draggable
  - Connect drag action to node creation flow
  - Add visual feedback during drag operation

- [ ] **6. Add Drag Node functionality**
  - Enable dragging to create Basis/Node on v3 canvas
  - Define drop zone detection on canvas
  - Create node at drop position
  - Persist new node to backend
  - Emit socket event for real-time sync

- [ ] **7. Add Drag from Search functionality**
  - Enable dragging search results onto canvas
  - Connect dragged Basis to the current Focus
  - Create FocusBasis relationship on drop
  - Position node at drop location
  - Update interface state

- [ ] **8. Add Feedback to v3 interface**
  - Create feedback submission form/modal
  - Allow user to describe their experience
  - Optional: Add screenshot capture
  - Send feedback to backend/email/Slack
  - Show confirmation on successful submission

- [ ] **9. Add Support to v3 interface**
  - Create support message form
  - Categorize support requests (bug, question, feature)
  - Integrate with support ticketing system
  - Show estimated response time
  - Add knowledge base/FAQ quick links

## v3 Interface - UI/UX

- [ ] **10. Update Node Detail Dialog**
  - Redesign for clean, minimal look
  - Improve information hierarchy
  - Add smooth open/close animations
  - Ensure responsive layout
  - Optimize for quick scanning and editing

- [ ] **11. Add Search in Floating TextField**
  - Implement search functionality for Focuses
  - Implement search functionality for Basis
  - Show results in autocomplete dropdown
  - Enable keyboard navigation of results
  - Support both text and semantic search modes

- [ ] **12. Add Node Option View**
  - Create floating action buttons around nodes
  - Display with animated motion on hover/click
  - Open options with single click
  - Include actions: Edit, Delete, Connect, Chat, Details
  - Smooth entrance/exit animations

## Monetization & Engagement

- [ ] **13. Implement Credit System for AI Requests**
  - Define credit costs per request type
  - Track user credit balance
  - Deduct credits on AI request completion
  - Show credit balance in UI
  - Add low-credit warnings
  - Integrate with Stripe for credit purchases

- [ ] **14. Add Gamification Elements**
  - **Badges for Focus:**
    - Define badge criteria based on session engagement
    - Award badges for milestones (nodes created, connections made, time spent)
    - Display earned badges on Focus and profile
  - **Streaks:**
    - Track consecutive days of Focus engagement
    - Show current streak in UI
    - Reward streak milestones
  - **Perk Cards:**
    - Design card-game style tool cards
    - Define perks/tools as collectible cards
    - Display in card deck view
    - Allow card activation for special features

## Focus & Navigation

- [ ] **15. Add Archetypes to Focus**
  - Define Archetype personas (Guide, Analyst, Creator, etc.)
  - Allow user to assign Archetype to Focus
  - Archetype assists in navigating the Focus
  - Archetype suggests questions and offers insights
  - Customize Archetype personality and expertise

- [ ] **16. Create Slot Layouts for Node Placement**
  - Define slot grid/pattern for Focus canvas
  - Nodes lock into slots like jewels
  - Implement magnet/snap behavior when dropped near slot
  - Visual indicators for available slots
  - Support different slot shapes and arrangements

- [ ] **17. Create Slot Layout Tool**
  - Enable users to create custom slot layouts
  - Drag-and-drop slot positioning
  - Save custom layouts to Focus
  - Share layouts as templates
  - Import/export layout configurations

- [ ] **18. Create Atlases**
  - Define Atlas as Path Template for Focus navigation
  - Include predefined slots for node placement
  - Guide users through structured exploration
  - Support Atlas versioning
  - Allow Atlas customization and forking

## Content Parsing

- [ ] **19. Parse Docs from Floating Text View**
  - Detect document uploads/pastes in text view
  - Extract text content from PDFs, DOCX, TXT
  - Parse into structured sections
  - Create Basis objects from parsed content
  - Show parsing progress and results

- [ ] **20. Parse Links from Floating Text View**
  - Detect YouTube video URLs
  - Detect article/webpage URLs
  - Fetch metadata (title, description, thumbnail)
  - For YouTube: Extract transcript if available
  - For articles: Extract main content
  - Create Basis objects from parsed content

- [ ] **21. Create New Focus from Parsed Content**
  - Allow creating Focus from parsed Docs
  - Allow creating Focus from parsed Videos
  - Allow creating Focus from parsed Links
  - Auto-populate Focus with extracted Basis nodes
  - Generate initial node layout based on content structure

## Backend

- [ ] **22. CRW5: Upgrade for Better Processing**
  - Improve planning capabilities for complex requests
  - Enhance intent classifiers for better routing
  - Upgrade response formatting for consistency
  - Add multi-step execution tracking
  - Improve error recovery and retry logic
  - Optimize token usage and response quality

