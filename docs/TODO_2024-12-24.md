# To-Do List - December 24, 2024

## V3 Interface Tasks

- [ ] **1. Make functional create new focus left drawer**
  - Implement the drawer UI for creating a new Focus
  - Connect to Focus creation API
  - Update context state when Focus is created

- [ ] **2. Add node to interface**
  - Enable adding nodes to the React Flow canvas
  - Connect node creation to Interface state
  - Persist node data to backend

- [ ] **2.5. Add List and Search for Focuses and Bases**
  - Enable listing user's Focuses and Bases via socket events
  - Implement search across Focuses and Bases
  - Socket events: `user:list-focuses`, `user:list-bases`, `user:search`
  - REST endpoints: `GET /api/basis`, `GET /api/basis/user/:userId`, `GET /api/basis/search`


- [ ] **2.6. Load Focus by ID**
  - Load a Focus with full details for the interface
  - Fetch bases and interface data
  - Will add more customization later

  ### Frontend Implementation Guide: Load Focus by ID

  #### API Endpoints
  | Method | Endpoint | Description |
      |--------|----------|-------------|
  | GET | `/api/focus/:id` | Get focus with bases |
  | GET | `/api/focus/:id/interface` | Get focus interface JSON |
  | GET | `/api/focus/:id/bases` | Get all bases in focus |

  #### Response: GET /api/focus/:id
    ```typescript
    interface GetFocusResponse {
      success: boolean;
      data?: {
        id: string;
        title: string;
        description: string | null;
        imageUrl: string | null;
        metadata: object | null;
        interface: object | null;  // React Flow nodes/edges
        createdAt: Date | string;
        updatedAt: Date | string;
        userId: string;
        atlasId: string | null;
        pathId: string | null;
        user: { id: string; name: string; email: string };
        bases: Array<{
          id: string;
          focusId: string;
          basisId: string;
          position: { x: number; y: number } | null;
          basis: {
            id: string;
            title: string;
            description: string | null;
            entityType: string;
            metadata: object;
            sourceEntityId: string | null;
          };
        }>;
      };
      error?: string;
    }
    ```

  #### Response: GET /api/focus/:id/interface
    ```typescript
    interface FocusInterface {
      goal: {
        id: string;
        name: string;
        description: string;
        icon?: string;
      };
      nodes: Array<{
        id: string;
        type: string;
        position: { x: number; y: number };
        data: {
          label: string;
          description?: string;
          entityType: string;
          basisId: string;
        };
      }>;
      edges: Array<{
        id: string;
        source: string;
        target: string;
        type?: string;
      }>;
    }
    ```

  #### React Hook: useFocus
    ```typescript
    import { useState, useEffect, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    interface FocusData {
      focus: GetFocusResponse['data'];
      interface: FocusInterface | null;
    }

    export function useFocus(focusId: string | null) {
      const [data, setData] = useState<FocusData | null>(null);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const loadFocus = useCallback(async () => {
        if (!focusId) return;

        setLoading(true);
        setError(null);

        try {
          // Fetch focus and interface in parallel
          const [focusRes, interfaceRes] = await Promise.all([
            fetch(`${API_BASE}/api/focus/${focusId}`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
            fetch(`${API_BASE}/api/focus/${focusId}/interface`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
          ]);

          const focusData = await focusRes.json();
          const interfaceData = await interfaceRes.json();

          if (!focusData.success) {
            throw new Error(focusData.error || 'Failed to load focus');
          }

          setData({
            focus: focusData.data,
            interface: interfaceData.success ? interfaceData.data : null,
          });
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to load focus');
        } finally {
          setLoading(false);
        }
      }, [focusId]);

      useEffect(() => {
        loadFocus();
      }, [loadFocus]);

      return { data, loading, error, refetch: loadFocus };
    }
    ```

- [ ] **2.7. Edit Focus Details & Metadata**
  - Allow editing focus title, description, metadata
  - Update focus via API
  - Optimistic updates with rollback on error

  ### Frontend Implementation Guide: Edit Focus

  #### API Endpoint
    ```
    PUT /api/focus/:id
    ```

  #### Request Body
    ```typescript
    interface UpdateFocusRequest {
      title?: string;
      description?: string;
      imageUrl?: string;
      metadata?: object;
      interface?: object;  // React Flow nodes/edges
    }
    ```

  #### Response
    ```typescript
    interface UpdateFocusResponse {
      success: boolean;
      data?: Focus;
      error?: string;
    }
    ```

  #### React Hook: useUpdateFocus
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useUpdateFocus() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const updateFocus = useCallback(async (
        focusId: string,
        updates: UpdateFocusRequest
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(updates),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to update focus');
          }

          return result.data;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Update failed';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { updateFocus, loading, error };
    }
    ```

  #### Inline Edit with Optimistic Update
    ```typescript
    const handleTitleBlur = async (newTitle: string) => {
      if (newTitle === focus.title) return;

      // Optimistic update
      const previousTitle = focus.title;
      setFocus(prev => ({ ...prev, title: newTitle }));

      try {
        await updateFocus(focus.id, { title: newTitle });
      } catch (err) {
        // Rollback on error
        setFocus(prev => ({ ...prev, title: previousTitle }));
      }
    };
    ```

- [ ] **3. Make request to focus AI**
  - Wire up the request submission flow
  - Display results in the interface via custom Snackbar (ResponseSnackbar)


  ### Frontend Implementation Guide: Focus AI Request via Socket

  #### Socket Event: `focus:request`

  **Direction:** Client → Server

  **Request Data:**
    ```typescript
    interface FocusRequestData {
      focusId: string;              // Required - which Focus this request belongs to
      input: string;                // Required - user's message/prompt
      researchEnabled: boolean;     // Research toggle from UI
      referencedBasisIds?: string[]; // Optional - Bases the request is about
      requestType?: 'AI_GENERATION' | 'ENTITY_CREATE' | 'ENTITY_UPDATE' | 'ENTITY_DELETE' | 'ANALYSIS' | 'CUSTOM';
    }
    ```

  **Acknowledgment:**
    ```typescript
    interface FocusRequestAck {
      success: boolean;
      requestId?: string;   // Database Request record ID
      workflowId?: string;  // CRW3 workflow tracking ID
      error?: string;
    }
    ```

  #### Server → Client Events

  | Event | Description |
      |-------|-------------|
  | `focus:request-started` | Request processing has begun |
  | `focus:request-progress` | Progress update during processing |
  | `focus:request-complete` | Request completed successfully |
  | `focus:request-error` | Request failed |
  | `change-batch-pending` | AI proposed changes (requires approval) |

  **Event Payloads:**
    ```typescript
    interface FocusRequestStartedData {
      requestId: string;
      focusId: string;
      workflowId: string;
      timestamp: Date;
    }

    interface FocusRequestProgressData {
      requestId: string;
      focusId: string;
      stage: 'CLASSIFYING' | 'RESEARCHING' | 'ROUTING' | 'EXECUTING' | 'FINALIZING';
      message: string;
      progress?: number; // 0-100
      timestamp: Date;
    }

    interface FocusRequestCompleteData {
      requestId: string;
      focusId: string;
      workflowId: string;
      response: string;           // AI response text
      batchId?: string;           // If changes proposed (use for approval)
      researchContext?: any;      // If research was enabled
      duration: number;           // Processing time in ms
      timestamp: Date;
    }

    interface FocusRequestErrorData {
      requestId: string;
      focusId: string;
      error: string;
      recoverable: boolean;
      timestamp: Date;
    }
    ```

  #### React Hook: useFocusRequest
    ```typescript
    import { useState, useCallback, useEffect } from 'react';
    import { useSocket } from './useSocket';

    interface RequestState {
      isProcessing: boolean;
      stage: string | null;
      progress: number;
      response: string | null;
      batchId: string | null;
      error: string | null;
    }

    export function useFocusRequest(focusId: string) {
      const { socket } = useSocket();
      const [state, setState] = useState<RequestState>({
        isProcessing: false,
        stage: null,
        progress: 0,
        response: null,
        batchId: null,
        error: null,
      });

      // Subscribe to focus room on mount
      useEffect(() => {
        if (!socket || !focusId) return;

        socket.emit('focus:subscribe', { focusId });

        return () => {
          socket.emit('focus:unsubscribe', { focusId });
        };
      }, [socket, focusId]);

      // Listen for request events
      useEffect(() => {
        if (!socket) return;

        socket.on('focus:request-started', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            isProcessing: true,
            stage: 'STARTED',
            progress: 0,
            error: null,
          }));
        });

        socket.on('focus:request-progress', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            stage: data.stage,
            progress: data.progress || 0,
          }));
        });

        socket.on('focus:request-complete', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            isProcessing: false,
            stage: 'COMPLETE',
            progress: 100,
            response: data.response,
            batchId: data.batchId || null,
          }));
        });

        socket.on('focus:request-error', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            isProcessing: false,
            stage: 'ERROR',
            error: data.error,
          }));
        });

        return () => {
          socket.off('focus:request-started');
          socket.off('focus:request-progress');
          socket.off('focus:request-complete');
          socket.off('focus:request-error');
        };
      }, [socket, focusId]);

      const sendRequest = useCallback(async (
        input: string,
        options: {
          researchEnabled?: boolean;
          referencedBasisIds?: string[];
          requestType?: string;
        } = {}
      ) => {
        if (!socket) throw new Error('Socket not connected');

        setState(prev => ({
          ...prev,
          isProcessing: true,
          stage: 'SENDING',
          progress: 0,
          response: null,
          batchId: null,
          error: null,
        }));

        return new Promise<{ requestId: string; workflowId: string }>((resolve, reject) => {
          socket.emit('focus:request', {
            focusId,
            input,
            researchEnabled: options.researchEnabled || false,
            referencedBasisIds: options.referencedBasisIds,
            requestType: options.requestType,
          }, (ack) => {
            if (ack.success) {
              resolve({
                requestId: ack.requestId!,
                workflowId: ack.workflowId!,
              });
            } else {
              setState(prev => ({
                ...prev,
                isProcessing: false,
                error: ack.error || 'Request failed',
              }));
              reject(new Error(ack.error || 'Request failed'));
            }
          });
        });
      }, [socket, focusId]);

      const reset = useCallback(() => {
        setState({
          isProcessing: false,
          stage: null,
          progress: 0,
          response: null,
          batchId: null,
          error: null,
        });
      }, []);

      return {
        ...state,
        sendRequest,
        reset,
      };
    }
    ```

  #### Usage in Component
    ```typescript
    import { useState } from 'react';
    import { TextField, Button, LinearProgress, Alert, Box } from '@mui/material';
    import { useFocusRequest } from '@/hooks/useFocusRequest';

    export function FocusRequestInput({ focusId }: { focusId: string }) {
      const [input, setInput] = useState('');
      const [researchEnabled, setResearchEnabled] = useState(false);

      const {
        isProcessing,
        stage,
        progress,
        response,
        batchId,
        error,
        sendRequest,
        reset,
      } = useFocusRequest(focusId);

      const handleSubmit = async () => {
        if (!input.trim()) return;

        try {
          await sendRequest(input, { researchEnabled });
          setInput(''); // Clear input on success
        } catch (err) {
          console.error('Request failed:', err);
        }
      };

      return (
        <Box>
          <TextField
            fullWidth
            multiline
            rows={3}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask the AI to help with your focus..."
            disabled={isProcessing}
          />

          <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
            <Button
              variant="contained"
              onClick={handleSubmit}
              disabled={isProcessing || !input.trim()}
            >
              {isProcessing ? 'Processing...' : 'Send Request'}
            </Button>

            <FormControlLabel
              control={
                <Switch
                  checked={researchEnabled}
                  onChange={(e) => setResearchEnabled(e.target.checked)}
                  disabled={isProcessing}
                />
              }
              label="Enable Research"
            />
          </Box>

          {isProcessing && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="body2" color="text.secondary">
                {stage}: {progress}%
              </Typography>
              <LinearProgress variant="determinate" value={progress} />
            </Box>
          )}

          {error && (
            <Alert severity="error" sx={{ mt: 2 }} onClose={reset}>
              {error}
            </Alert>
          )}

          {response && (
            <Box sx={{ mt: 2, p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>
              <Typography variant="body1">{response}</Typography>
              {batchId && (
                <Alert severity="info" sx={{ mt: 2 }}>
                  AI proposed changes. Review and approve them in the changes panel.
                </Alert>
              )}
            </Box>
          )}
        </Box>
      );
    }
    ```

  #### Handling Proposed Changes (Batch Approval)

  When `batchId` is returned, the AI has proposed changes that need approval:

    ```typescript
    // Listen for batch pending event
    socket.on('change-batch-pending', (data) => {
      // data = { batchId, messageId, conversationId, changes, timestamp }
      // Show approval UI with data.changes
      setPendingChanges(data.changes);
      setCurrentBatchId(data.batchId);
    });

    // Approve batch
    socket.emit('approve-batch', { batchId }, (ack) => {
      if (ack.success) {
        console.log(`Applied ${ack.appliedChanges} changes`);
      }
    });

    // Reject batch
    socket.emit('reject-batch', { batchId, reason: 'Not what I wanted' }, (ack) => {
      if (ack.success) {
        console.log('Changes rejected');
      }
    });
    ```

- [ ] **3.1 Create Basis/Node object from the response**
  - Create Basis/Node objects from AI responses
  - Basis is created automatically when batch is approved
  - Listen for `basis-created` socket event

  ### Frontend Implementation Guide: Basis Creation from AI Response

  #### How It Works

  1. User sends request via `focus:request` socket event
  2. AI processes and proposes changes (CREATE operations for Basis)
  3. `change-batch-pending` event is emitted with proposed changes
  4. User reviews and approves via `approve-batch`
  5. Backend creates Basis records
  6. `basis-created` event is emitted for each new Basis

  #### Socket Event: `basis-created`

  **Direction:** Server → Client

  **Payload:**
    ```typescript
    interface BasisCreatedData {
      basis: {
        id: string;
        title: string;
        description?: string;
        entityType: string;
        metadata: any;
      };
      timestamp: Date;
    }
    ```

  #### Listening for New Bases
    ```typescript
    useEffect(() => {
      if (!socket) return;

      socket.on('basis-created', (data) => {
        console.log('New basis created:', data.basis.title);

        // Add to local state
        setBases(prev => [...prev, data.basis]);

        // Show notification
        showNotification({
          message: `Created: ${data.basis.title}`,
          type: 'success',
        });
      });

      return () => {
        socket.off('basis-created');
      };
    }, [socket]);
    ```

  #### Adding Basis to Focus Interface

  After a Basis is created, you may want to add it to the Focus interface:

    ```typescript
    // Use the existing add-node endpoint
    const addBasisToFocus = async (focusId: string, basisId: string, position: { x: number; y: number }) => {
      const response = await fetch(`${API_BASE}/api/focus-basis/add`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({
          focusId,
          basisId,
          position,
        }),
      });

      return response.json();
    };
    ```

  #### Complete Flow Example
    ```typescript
    function FocusWorkspace({ focusId }: { focusId: string }) {
      const { socket } = useSocket();
      const [pendingBatch, setPendingBatch] = useState<any>(null);
      const [nodes, setNodes] = useNodesState([]);

      // Listen for batch pending
      useEffect(() => {
        if (!socket) return;

        socket.on('change-batch-pending', (data) => {
          setPendingBatch(data);
        });

        socket.on('change-batch-approved', (data) => {
          setPendingBatch(null);
          // Refresh focus to get new nodes
          refetchFocus();
        });

        socket.on('basis-created', (data) => {
          // Optionally auto-add to canvas at default position
          const newNode = {
            id: data.basis.id,
            type: getNodeType(data.basis.entityType),
            position: { x: 100, y: nodes.length * 100 },
            data: {
              label: data.basis.title,
              description: data.basis.description,
              entityType: data.basis.entityType,
              basisId: data.basis.id,
            },
          };
          setNodes(prev => [...prev, newNode]);
        });

        return () => {
          socket.off('change-batch-pending');
          socket.off('change-batch-approved');
          socket.off('basis-created');
        };
      }, [socket, nodes.length]);

      const handleApprove = () => {
        if (!pendingBatch) return;
        socket.emit('approve-batch', { batchId: pendingBatch.batchId }, (ack) => {
          if (!ack.success) {
            console.error('Approval failed:', ack.error);
          }
        });
      };

      const handleReject = () => {
        if (!pendingBatch) return;
        socket.emit('reject-batch', { batchId: pendingBatch.batchId }, (ack) => {
          setPendingBatch(null);
        });
      };

      return (
        <Box>
          <ReactFlow nodes={nodes} ... />

          {pendingBatch && (
            <Dialog open>
              <DialogTitle>Review Proposed Changes</DialogTitle>
              <DialogContent>
                {pendingBatch.changes.map((change: any) => (
                  <Box key={change.id}>
                    <Typography>
                      {change.operation}: {change.proposedData.title}
                    </Typography>
                  </Box>
                ))}
              </DialogContent>
              <DialogActions>
                <Button onClick={handleReject}>Reject</Button>
                <Button onClick={handleApprove} variant="contained">
                  Approve All
                </Button>
              </DialogActions>
            </Dialog>
          )}
        </Box>
      );
    }
    ```


- [ ] **4. Connect and Disconnect nodes**
  - Implement edge creation between nodes
  - Save edge connections to Interface state
  - Handle connection validation

    ### Frontend Implementation Guide: Connect and Disconnect Nodes

    #### API Endpoints
    | Method | Endpoint | Description |
        |--------|----------|-------------|
    | POST | `/api/focus/:id/connect-nodes` | Create edge between two nodes |
    | DELETE | `/api/focus/:id/disconnect-nodes` | Remove edge between nodes |
    | PUT | `/api/focus/:id/edge/:edgeId` | Update an existing edge |
    | POST | `/api/focus/:id/edges/batch` | Batch edge operations |

    #### Connect Nodes Request
    ```typescript
    interface ConnectNodesRequest {
      sourceNodeId: string;      // Required - Basis ID of source node
      targetNodeId: string;      // Required - Basis ID of target node
      edgeType?: 'animated' | 'default' | 'smartPulseButton'; // Default: 'animated'
      sourceHandle?: string;     // Optional - Handle ID on source node
      targetHandle?: string;     // Optional - Handle ID on target node
      relationship?: {           // Optional - Semantic relationship
        type: 'dependency' | 'sequence' | 'reference' | 'grouping' | 'contrast' | 'derivation';
        direction: 'forward' | 'backward' | 'bidirectional';
        strength?: number;       // 0-1 (default: 1)
        label?: string;
      };
      styling?: {                // Optional - Visual styling
        strokeColor?: string;
        strokeWidth?: number;
        animated?: boolean;
      };
    }
    ```

    #### Connect Nodes Response
    ```typescript
    interface ConnectNodesResponse {
      success: boolean;
      data?: {
        edge: FlowEdge;
        focusId: string;
      };
      error?: string;
    }
    ```

    #### Disconnect Nodes Request
    ```typescript
    interface DisconnectNodesRequest {
      edgeId?: string;           // Option 1: Delete by edge ID
      sourceNodeId?: string;     // Option 2: Delete by source + target
      targetNodeId?: string;     // (both required if using this option)
    }
    ```

    #### React Hook: useConnectNodes
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useConnectNodes() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const connectNodes = useCallback(async (
        focusId: string,
        data: {
          sourceNodeId: string;
          targetNodeId: string;
          relationship?: {
            type: string;
            direction: string;
            strength?: number;
            label?: string;
          };
          edgeType?: string;
        }
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}/connect-nodes`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(data),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to connect nodes');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { connectNodes, loading, error };
    }
    ```

    #### React Hook: useDisconnectNodes
    ```typescript
    export function useDisconnectNodes() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const disconnectNodes = useCallback(async (
        focusId: string,
        data: { edgeId?: string; sourceNodeId?: string; targetNodeId?: string }
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}/disconnect-nodes`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(data),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to disconnect nodes');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { disconnectNodes, loading, error };
    }
    ```

    #### React Flow Integration (onConnect callback)
    ```typescript
    import { useCallback } from 'react';
    import { Connection, useReactFlow } from 'reactflow';

    const { connectNodes, loading } = useConnectNodes();

    const onConnect = useCallback(async (connection: Connection) => {
      if (!connection.source || !connection.target) return;

      try {
        const result = await connectNodes(focusId, {
          sourceNodeId: connection.source,
          targetNodeId: connection.target,
          relationship: {
            type: 'sequence',
            direction: 'forward',
          },
        });

        // Edge is auto-added via socket event or refetch
        console.log('Connected:', result.data.edge);
      } catch (err) {
        console.error('Failed to connect nodes:', err);
      }
    }, [focusId, connectNodes]);
    ```

    #### Socket Events
    | Event | Direction | Payload |
        |-------|-----------|---------|
    | `focus:nodes-connected` | Server → Client | `{ focusId, edge }` |
    | `focus:nodes-disconnected` | Server → Client | `{ focusId, edgeId, sourceNodeId, targetNodeId }` |
    | `focus:edge-updated` | Server → Client | `{ focusId, edge }` |
    | `focus:edges-batch-updated` | Server → Client | `{ focusId, created, deleted, updated }` |

    #### Socket Event Listener
    ```typescript
    useEffect(() => {
      if (!socket) return;

      socket.on('focus:nodes-connected', (data) => {
        // data = { focusId, edge }
        setEdges(prev => [...prev, data.edge]);
      });

      socket.on('focus:nodes-disconnected', (data) => {
        // data = { focusId, edgeId, sourceNodeId, targetNodeId }
        setEdges(prev => prev.filter(e => e.id !== data.edgeId));
      });

      socket.on('focus:edge-updated', (data) => {
        // data = { focusId, edge }
        setEdges(prev => prev.map(e => e.id === data.edge.id ? data.edge : e));
      });

      return () => {
        socket.off('focus:nodes-connected');
        socket.off('focus:nodes-disconnected');
        socket.off('focus:edge-updated');
      };
    }, [socket]);
    ```

    #### Batch Operations Example
    ```typescript
    const batchResult = await fetch(`${API_BASE}/api/focus/${focusId}/edges/batch`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`,
      },
      body: JSON.stringify({
        connect: [
          { sourceNodeId: 'node1', targetNodeId: 'node2' },
          { sourceNodeId: 'node2', targetNodeId: 'node3' },
        ],
        disconnect: [
          { edgeId: 'edge-old1-old2' },
        ],
        update: [
          { edgeId: 'edge-existing', styling: { strokeColor: '#ff0000' } },
        ],
      }),
    });
    ```


- [x] **4.1. Auto-save node position changes**
  - Batch update node positions after drag operations
  - Debounced auto-save to prevent excessive API calls
  - Real-time sync via socket events


- [x] **4.2. Delete Focus and Basis with proper connection severing**
  - Safely delete Basis with all related records (BasisCommit, FocusBasis, RequestBasis, Message references)
  - Safely delete Focus with option to also delete associated Bases
  - Socket events emitted on deletion for real-time UI updates
  - Transaction-based deletion to ensure data integrity

  ### Frontend Implementation Guide: Delete Focus & Basis

  #### API Endpoints
  | Method | Endpoint | Description |
      |--------|----------|-------------|
  | DELETE | `/api/basis/:id` | Delete a Basis and sever all connections |
  | DELETE | `/api/focus/:id` | Delete a Focus (preserves Bases by default) |
  | DELETE | `/api/focus/:id?deleteBases=true` | Delete Focus AND all its Bases |

  #### Delete Basis Response
    ```typescript
    interface DeleteBasisResponse {
      success: boolean;
      data?: {
        message: string;
        deletedBasis: {
          id: string;
          title: string;
          entityType: string;
          atlasId: string | null;
          pathId: string | null;
        };
        severedConnections: {
          commits: number;        // BasisCommit records deleted
          focusBases: number;     // FocusBasis junction records deleted
          requestBases: number;   // RequestBasis junction records deleted
          messagesUpdated: number; // Messages with reference set to null
        };
      };
      error?: string;
    }
    ```

  #### Delete Focus Response
    ```typescript
    interface DeleteFocusResponse {
      success: boolean;
      data?: {
        message: string;
        deletedFocus: {
          id: string;
          title: string;
        };
        severedConnections: {
          commits: number;
          focusBases: number;
          requests: number;
          requestBases: number;
          contexts: number;
        };
        // Only present if deleteBases=true
        deletedBases?: {
          count: number;
          basisCommits: number;
          basisRequestBases: number;
          messagesUpdated: number;
        };
      };
      error?: string;
    }
    ```

  #### React Hook: useDeleteBasis
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useDeleteBasis() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const deleteBasis = useCallback(async (basisId: string) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/basis/${basisId}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to delete basis');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { deleteBasis, loading, error };
    }
    ```

  #### React Hook: useDeleteFocus
    ```typescript
    export function useDeleteFocus() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const deleteFocus = useCallback(async (
        focusId: string,
        options: { deleteBases?: boolean } = {}
      ) => {
        setLoading(true);
        setError(null);

        try {
          const url = options.deleteBases
            ? `${API_BASE}/api/focus/${focusId}?deleteBases=true`
            : `${API_BASE}/api/focus/${focusId}`;

          const response = await fetch(url, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to delete focus');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { deleteFocus, loading, error };
    }
    ```

  #### Socket Events
  | Event | Direction | Payload |
      |-------|-----------|---------|
  | `basis:deleted` | Server → Client | `{ basisId, severedConnections }` |
  | `focus:deleted` | Server → Client | `{ focusId, deletedBases }` |

  #### Socket Event Listener
    ```typescript
    useEffect(() => {
      if (!socket) return;

      socket.on('basis:deleted', (data) => {
        // Remove basis from local state
        setBases(prev => prev.filter(b => b.id !== data.basisId));
        // Also remove from any focus that contained it
        setNodes(prev => prev.filter(n => n.id !== data.basisId));
      });

      socket.on('focus:deleted', (data) => {
        // Remove focus from local state
        setFocuses(prev => prev.filter(f => f.id !== data.focusId));
        // Navigate away if viewing deleted focus
        if (currentFocusId === data.focusId) {
          router.push('/focuses');
        }
      });

      return () => {
        socket.off('basis:deleted');
        socket.off('focus:deleted');
      };
    }, [socket]);
    ```

- [ ] **5. Start chat from focus**
  - Open chat drawer from Focus context
  - Pre-populate chat with Focus information
  - Stream AI responses

- [ ] **6. Start chat from node**
  - Open chat drawer when clicking a node
  - Include node data as context for the chat
  - Allow node refinement through conversation

- [ ] **7. Refine request processing in back end**
  - Improve request handling logic
  - Add better error handling
  - Optimize response generation

- [ ] **8. Web request**
  - Implement web search/fetch functionality
  - Parse and display web results as Basis objects

- [ ] **9. Voice request**
  - Enable voice input for requests
  - Transcribe and process voice commands


    ### Frontend Implementation Guide: Focus Voice Transcription via Socket

    #### Overview

    The Focus Voice feature enables real-time voice transcription linked to a Focus workspace. Audio is streamed to the backend, transcribed via Speechmatics, semantically chunked, and optionally submitted to CRW3 for AI processing.

    #### Socket Events

    ##### Client → Server Events

    | Event | Description | Acknowledgment |
    |-------|-------------|----------------|
    | `focus:voice-start` | Start a voice session | `FocusVoiceAck` |
    | `focus:voice-audio` | Stream audio chunk | None |
    | `focus:voice-end` | End voice session | None |

    ##### Server → Client Events

    | Event | Description |
    |-------|-------------|
    | `focus:voice-started` | Session started confirmation |
    | `focus:voice-partial` | Real-time partial transcript (as user speaks) |
    | `focus:voice-transcript` | Final transcript segment (confirmed words) |
    | `focus:voice-chunk` | Semantic chunk from ConservativeRealtimeChunker |
    | `focus:voice-processing` | CRW3 submission started |
    | `focus:voice-error` | Error occurred |
    | `focus:voice-ended` | Session ended with full transcript |

    #### Event Type Definitions

    ```typescript
    // Client → Server: Start voice session
    interface FocusVoiceStartData {
      focusId: string;                    // Required - Focus to link session to
      researchEnabled: boolean;           // Enable research for CRW3 processing
      referencedBasisIds?: string[];      // Optional - Bases to reference
      requestType?: 'AI_GENERATION' | 'ENTITY_CREATE' | 'ENTITY_UPDATE' | 'ANALYSIS';
      config?: FocusVoiceConfig;
    }

    interface FocusVoiceConfig {
      language?: string;        // Default: 'en'
      enableChunking?: boolean; // Enable semantic chunking (default: false)
      autoSubmit?: boolean;     // Auto-submit to CRW3 on end (default: true)
    }

    // Client → Server: Stream audio
    interface FocusVoiceAudioData {
      sessionId: string;                  // Session ID from start ack
      audioChunk: ArrayBuffer | Buffer;   // PCM audio (16kHz, 16-bit, mono)
    }

    // Client → Server: End session
    interface FocusVoiceEndData {
      sessionId: string;
      submitToCRW3?: boolean;  // Override autoSubmit (default: true)
    }

    // Acknowledgment for start
    interface FocusVoiceAck {
      success: boolean;
      sessionId?: string;
      error?: string;
    }
    ```

    #### Server → Client Event Payloads

    ```typescript
    // Session started
    interface FocusVoiceStartedData {
      sessionId: string;
      focusId: string;
      timestamp: Date;
    }

    // Partial transcript (real-time, as user speaks)
    interface FocusVoicePartialData {
      sessionId: string;
      focusId: string;
      transcript: string;  // Current partial text
      timestamp: Date;
    }

    // Final transcript segment (confirmed words)
    interface FocusVoiceTranscriptData {
      sessionId: string;
      focusId: string;
      transcript: string;
      results: Array<{
        type: 'word' | 'punctuation';
        content: string;
        start_time: number;
        end_time: number;
        confidence?: number;
      }>;
      timestamp: Date;
    }

    // Semantic chunk (when enableChunking: true)
    interface FocusVoiceChunkData {
      sessionId: string;
      focusId: string;
      chunk: {
        id: string;
        text: string;
        wordCount: number;
        confidence: number;
        reason: string;  // Why chunk was created (e.g., 'topic_shift', 'pause')
      };
      timestamp: Date;
    }

    // CRW3 processing started
    interface FocusVoiceProcessingData {
      sessionId: string;
      focusId: string;
      fullTranscript: string;
      workflowId: string;
      timestamp: Date;
    }

    // Error occurred
    interface FocusVoiceErrorData {
      sessionId: string;
      focusId: string;
      error: string;
      code?: string;
      timestamp: Date;
    }

    // Session ended
    interface FocusVoiceEndedData {
      sessionId: string;
      focusId: string;
      fullTranscript: string;
      chunks: Array<{
        id: string;
        text: string;
        wordCount: number;
        confidence: number;
        reason: string;
      }>;
      timestamp: Date;
    }
    ```

    #### React Hook: useFocusVoice

    ```typescript
    import { useState, useCallback, useEffect, useRef } from 'react';
    import { useSocket } from './useSocket';

    interface VoiceState {
      isRecording: boolean;
      sessionId: string | null;
      partialTranscript: string;
      finalTranscript: string;
      chunks: Array<{ id: string; text: string; reason: string }>;
      isProcessing: boolean;
      error: string | null;
    }

    export function useFocusVoice(focusId: string) {
      const { socket } = useSocket();
      const mediaRecorderRef = useRef<MediaRecorder | null>(null);
      const audioContextRef = useRef<AudioContext | null>(null);
      const processorRef = useRef<ScriptProcessorNode | null>(null);

      const [state, setState] = useState<VoiceState>({
        isRecording: false,
        sessionId: null,
        partialTranscript: '',
        finalTranscript: '',
        chunks: [],
        isProcessing: false,
        error: null,
      });

      // Subscribe to focus room
      useEffect(() => {
        if (!socket || !focusId) return;
        socket.emit('focus:subscribe', { focusId });
        return () => {
          socket.emit('focus:unsubscribe', { focusId });
        };
      }, [socket, focusId]);

      // Listen for voice events
      useEffect(() => {
        if (!socket) return;

        socket.on('focus:voice-started', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({ ...prev, sessionId: data.sessionId }));
        });

        socket.on('focus:voice-partial', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({ ...prev, partialTranscript: data.transcript }));
        });

        socket.on('focus:voice-transcript', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            finalTranscript: prev.finalTranscript + ' ' + data.transcript,
            partialTranscript: '',
          }));
        });

        socket.on('focus:voice-chunk', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            chunks: [...prev.chunks, data.chunk],
          }));
        });

        socket.on('focus:voice-processing', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({ ...prev, isProcessing: true }));
        });

        socket.on('focus:voice-error', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            error: data.error,
            isRecording: false,
          }));
        });

        socket.on('focus:voice-ended', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({
            ...prev,
            isRecording: false,
            finalTranscript: data.fullTranscript,
            chunks: data.chunks,
          }));
        });

        // Also listen for CRW3 completion
        socket.on('focus:request-complete', (data) => {
          if (data.focusId !== focusId) return;
          setState(prev => ({ ...prev, isProcessing: false }));
        });

        return () => {
          socket.off('focus:voice-started');
          socket.off('focus:voice-partial');
          socket.off('focus:voice-transcript');
          socket.off('focus:voice-chunk');
          socket.off('focus:voice-processing');
          socket.off('focus:voice-error');
          socket.off('focus:voice-ended');
          socket.off('focus:request-complete');
        };
      }, [socket, focusId]);

      const startRecording = useCallback(async (options: {
        researchEnabled?: boolean;
        enableChunking?: boolean;
        autoSubmit?: boolean;
      } = {}) => {
        if (!socket) throw new Error('Socket not connected');

        setState(prev => ({
          ...prev,
          isRecording: true,
          partialTranscript: '',
          finalTranscript: '',
          chunks: [],
          error: null,
        }));

        return new Promise<string>(async (resolve, reject) => {
          // Start voice session on server
          socket.emit('focus:voice-start', {
            focusId,
            researchEnabled: options.researchEnabled || false,
            config: {
              enableChunking: options.enableChunking || false,
              autoSubmit: options.autoSubmit !== false,
            },
          }, async (ack) => {
            if (!ack.success) {
              setState(prev => ({
                ...prev,
                isRecording: false,
                error: ack.error || 'Failed to start voice session',
              }));
              reject(new Error(ack.error));
              return;
            }

            const sessionId = ack.sessionId!;
            setState(prev => ({ ...prev, sessionId }));

            try {
              // Get microphone access
              const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  sampleRate: 16000,
                  channelCount: 1,
                  echoCancellation: true,
                  noiseSuppression: true,
                },
              });

              // Create audio context for PCM conversion
              const audioContext = new AudioContext({ sampleRate: 16000 });
              audioContextRef.current = audioContext;

              const source = audioContext.createMediaStreamSource(stream);
              const processor = audioContext.createScriptProcessor(4096, 1, 1);
              processorRef.current = processor;

              processor.onaudioprocess = (e) => {
                const inputData = e.inputBuffer.getChannelData(0);
                // Convert Float32 to Int16 PCM
                const pcmData = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) {
                  const s = Math.max(-1, Math.min(1, inputData[i]));
                  pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }

                // Send audio chunk to server
                socket.emit('focus:voice-audio', {
                  sessionId,
                  audioChunk: pcmData.buffer,
                });
              };

              source.connect(processor);
              processor.connect(audioContext.destination);

              resolve(sessionId);
            } catch (err) {
              setState(prev => ({
                ...prev,
                isRecording: false,
                error: 'Microphone access denied',
              }));
              reject(err);
            }
          });
        });
      }, [socket, focusId]);

      const stopRecording = useCallback(async (submitToCRW3: boolean = true) => {
        const { sessionId } = state;
        if (!socket || !sessionId) return;

        // Stop audio processing
        if (processorRef.current) {
          processorRef.current.disconnect();
          processorRef.current = null;
        }
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }

        // End session on server
        socket.emit('focus:voice-end', { sessionId, submitToCRW3 });

        setState(prev => ({ ...prev, isRecording: false }));
      }, [socket, state.sessionId]);

      const reset = useCallback(() => {
        setState({
          isRecording: false,
          sessionId: null,
          partialTranscript: '',
          finalTranscript: '',
          chunks: [],
          isProcessing: false,
          error: null,
        });
      }, []);

      return {
        ...state,
        startRecording,
        stopRecording,
        reset,
      };
    }
    ```

    #### Usage in Component

    ```typescript
    import { useState } from 'react';
    import { Box, IconButton, Typography, LinearProgress, Chip, Stack } from '@mui/material';
    import MicIcon from '@mui/icons-material/Mic';
    import StopIcon from '@mui/icons-material/Stop';
    import { useFocusVoice } from '@/hooks/useFocusVoice';

    export function FocusVoiceInput({ focusId }: { focusId: string }) {
      const [researchEnabled, setResearchEnabled] = useState(false);

      const {
        isRecording,
        partialTranscript,
        finalTranscript,
        chunks,
        isProcessing,
        error,
        startRecording,
        stopRecording,
        reset,
      } = useFocusVoice(focusId);

      const handleToggleRecording = async () => {
        if (isRecording) {
          await stopRecording(true); // Submit to CRW3
        } else {
          await startRecording({
            researchEnabled,
            enableChunking: true,
            autoSubmit: true,
          });
        }
      };

      return (
        <Box>
          {/* Recording Button */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <IconButton
              onClick={handleToggleRecording}
              color={isRecording ? 'error' : 'primary'}
              size="large"
              disabled={isProcessing}
            >
              {isRecording ? <StopIcon /> : <MicIcon />}
            </IconButton>

            <Typography variant="body2" color="text.secondary">
              {isRecording ? 'Recording... Click to stop' : 'Click to start recording'}
            </Typography>
          </Box>

          {/* Live Transcript Display */}
          {(partialTranscript || finalTranscript) && (
            <Box sx={{ mt: 2, p: 2, bgcolor: 'background.paper', borderRadius: 1 }}>
              <Typography variant="body1">
                {finalTranscript}
                <span style={{ color: 'gray', fontStyle: 'italic' }}>
                  {partialTranscript}
                </span>
              </Typography>
            </Box>
          )}

          {/* Semantic Chunks */}
          {chunks.length > 0 && (
            <Stack direction="row" spacing={1} sx={{ mt: 2, flexWrap: 'wrap' }}>
              {chunks.map((chunk) => (
                <Chip
                  key={chunk.id}
                  label={chunk.text.substring(0, 50) + (chunk.text.length > 50 ? '...' : '')}
                  size="small"
                  variant="outlined"
                />
              ))}
            </Stack>
          )}

          {/* Processing Indicator */}
          {isProcessing && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="body2" color="text.secondary">
                Processing with AI...
              </Typography>
              <LinearProgress />
            </Box>
          )}

          {/* Error Display */}
          {error && (
            <Typography color="error" sx={{ mt: 2 }}>
              {error}
            </Typography>
          )}
        </Box>
      );
    }
    ```

    #### Audio Format Requirements

    The backend expects audio in the following format:
    - **Encoding:** PCM signed 16-bit little-endian (`pcm_s16le`)
    - **Sample Rate:** 16000 Hz
    - **Channels:** 1 (mono)

    The React hook above handles the conversion from the browser's Float32 audio to Int16 PCM.

    #### Flow Diagram

    ```
    ┌─────────────────────────────────────────────────────────────────────────┐
    │                           FOCUS VOICE FLOW                               │
    └─────────────────────────────────────────────────────────────────────────┘

    Frontend                          Backend                      Speechmatics
    ────────                          ───────                      ────────────
        │                                │                              │
        │  focus:voice-start             │                              │
        │ ─────────────────────────────► │                              │
        │                                │  WebSocket Connect           │
        │                                │ ────────────────────────────►│
        │  focus:voice-started           │                              │
        │ ◄───────────────────────────── │                              │
        │                                │                              │
        │  focus:voice-audio (loop)      │                              │
        │ ─────────────────────────────► │  Audio Stream                │
        │                                │ ────────────────────────────►│
        │                                │                              │
        │  focus:voice-partial           │  AddPartialTranscript        │
        │ ◄───────────────────────────── │ ◄────────────────────────────│
        │                                │                              │
        │  focus:voice-transcript        │  AddTranscript               │
        │ ◄───────────────────────────── │ ◄────────────────────────────│
        │                                │                              │
        │  focus:voice-chunk             │  (Chunker processes)         │
        │ ◄───────────────────────────── │                              │
        │                                │                              │
        │  focus:voice-end               │                              │
        │ ─────────────────────────────► │  EndOfStream                 │
        │                                │ ────────────────────────────►│
        │                                │                              │
        │  focus:voice-ended             │                              │
        │ ◄───────────────────────────── │                              │
        │                                │                              │
        │  focus:voice-processing        │                              │
        │ ◄───────────────────────────── │                              │
        │                                │                              │
        │                                │  processFocusRequest()       │
        │                                │  (CRW3 workflow)             │
        │                                │                              │
        │  focus:request-complete        │                              │
        │ ◄───────────────────────────── │                              │
        │                                │                              │
    ```

    #### Related Events

    After voice processing completes, the standard Focus request events are emitted:
    - `focus:request-complete` - AI response ready
    - `change-batch-pending` - If AI proposed changes (requires approval)
    - `basis-created` - When new Basis entities are created


- [ ] **10. Focus API** *(Backend)*
  - Build Focus CRUD endpoints
  - Handle Focus state management

- [ ] **11. Focus socket** *(Backend)*
  - Implement WebSocket for real-time Focus updates
  - Handle live collaboration events

- [ ] **12. Focus AI** *(Backend)*
  - AI processing pipeline for Focus requests
  - Generate and refine Basis objects

- [ ] **13. Search objects**
  - Implement search across Focus/Basis/Result objects
  - Add filtering and sorting capabilities

- [ ] **14. Simplify and Refine**
  - Clean up codebase and remove redundancy
  - Optimize performance and UX flows

- [ ] **15. Live Brainstorming (Auto Request Chunking and AI Fulfillment)**
  - Auto-chunk complex requests into sub-tasks
  - Real-time AI fulfillment as user types/speaks

- [ ] **16. Begin Lens Integration**
  - Connect Lens data sources
  - Map Lens entities to Focus/Basis structures

