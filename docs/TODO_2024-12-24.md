# To-Do List - December 24, 2024

## V3 Interface Tasks

- [ ] **1. Make functional create new focus left drawer**
  - Implement the drawer UI for creating a new Focus
  - Connect to Focus creation API
  - Update context state when Focus is created

- [ ] **2. Add node to interface**
  - Enable adding nodes to the React Flow canvas
  - Connect node creation to Interface state
  - Persist node data to backend

- [ ] **2.5. Add List and Search for Focuses and Bases**
  - Enable listing user's Focuses and Bases via socket events
  - Implement search across Focuses and Bases
  - Socket events: `user:list-focuses`, `user:list-bases`, `user:search`
  - REST endpoints: `GET /api/basis`, `GET /api/basis/user/:userId`, `GET /api/basis/search`


- [ ] **2.6. Load Focus by ID**
  - Load a Focus with full details for the interface
  - Fetch bases and interface data
  - Will add more customization later

  ### Frontend Implementation Guide: Load Focus by ID

  #### API Endpoints
  | Method | Endpoint | Description |
      |--------|----------|-------------|
  | GET | `/api/focus/:id` | Get focus with bases |
  | GET | `/api/focus/:id/interface` | Get focus interface JSON |
  | GET | `/api/focus/:id/bases` | Get all bases in focus |

  #### Response: GET /api/focus/:id
    ```typescript
    interface GetFocusResponse {
      success: boolean;
      data?: {
        id: string;
        title: string;
        description: string | null;
        imageUrl: string | null;
        metadata: object | null;
        interface: object | null;  // React Flow nodes/edges
        createdAt: Date | string;
        updatedAt: Date | string;
        userId: string;
        atlasId: string | null;
        pathId: string | null;
        user: { id: string; name: string; email: string };
        bases: Array<{
          id: string;
          focusId: string;
          basisId: string;
          position: { x: number; y: number } | null;
          basis: {
            id: string;
            title: string;
            description: string | null;
            entityType: string;
            metadata: object;
            sourceEntityId: string | null;
          };
        }>;
      };
      error?: string;
    }
    ```

  #### Response: GET /api/focus/:id/interface
    ```typescript
    interface FocusInterface {
      goal: {
        id: string;
        name: string;
        description: string;
        icon?: string;
      };
      nodes: Array<{
        id: string;
        type: string;
        position: { x: number; y: number };
        data: {
          label: string;
          description?: string;
          entityType: string;
          basisId: string;
        };
      }>;
      edges: Array<{
        id: string;
        source: string;
        target: string;
        type?: string;
      }>;
    }
    ```

  #### React Hook: useFocus
    ```typescript
    import { useState, useEffect, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    interface FocusData {
      focus: GetFocusResponse['data'];
      interface: FocusInterface | null;
    }

    export function useFocus(focusId: string | null) {
      const [data, setData] = useState<FocusData | null>(null);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const loadFocus = useCallback(async () => {
        if (!focusId) return;

        setLoading(true);
        setError(null);

        try {
          // Fetch focus and interface in parallel
          const [focusRes, interfaceRes] = await Promise.all([
            fetch(`${API_BASE}/api/focus/${focusId}`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
            fetch(`${API_BASE}/api/focus/${focusId}/interface`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
          ]);

          const focusData = await focusRes.json();
          const interfaceData = await interfaceRes.json();

          if (!focusData.success) {
            throw new Error(focusData.error || 'Failed to load focus');
          }

          setData({
            focus: focusData.data,
            interface: interfaceData.success ? interfaceData.data : null,
          });
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to load focus');
        } finally {
          setLoading(false);
        }
      }, [focusId]);

      useEffect(() => {
        loadFocus();
      }, [loadFocus]);

      return { data, loading, error, refetch: loadFocus };
    }
    ```

- [ ] **2.7. Edit Focus Details & Metadata**
  - Allow editing focus title, description, metadata
  - Update focus via API
  - Optimistic updates with rollback on error

  ### Frontend Implementation Guide: Edit Focus

  #### API Endpoint
    ```
    PUT /api/focus/:id
    ```

  #### Request Body
    ```typescript
    interface UpdateFocusRequest {
      title?: string;
      description?: string;
      imageUrl?: string;
      metadata?: object;
      interface?: object;  // React Flow nodes/edges
    }
    ```

  #### Response
    ```typescript
    interface UpdateFocusResponse {
      success: boolean;
      data?: Focus;
      error?: string;
    }
    ```

  #### React Hook: useUpdateFocus
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useUpdateFocus() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const updateFocus = useCallback(async (
        focusId: string,
        updates: UpdateFocusRequest
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(updates),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to update focus');
          }

          return result.data;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Update failed';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { updateFocus, loading, error };
    }
    ```

  #### Inline Edit with Optimistic Update
    ```typescript
    const handleTitleBlur = async (newTitle: string) => {
      if (newTitle === focus.title) return;

      // Optimistic update
      const previousTitle = focus.title;
      setFocus(prev => ({ ...prev, title: newTitle }));

      try {
        await updateFocus(focus.id, { title: newTitle });
      } catch (err) {
        // Rollback on error
        setFocus(prev => ({ ...prev, title: previousTitle }));
      }
    };
    ```

- [ ] **3. Make request to focus AI (create object)**
  - Wire up the request submission flow
  - Create Basis/Result objects from AI responses
  - Display results in the interface

- [ ] **4. Connect and Disconnect nodes**
  - Implement edge creation between nodes
  - Save edge connections to Interface state
  - Handle connection validation

    ### Frontend Implementation Guide: Connect and Disconnect Nodes

    #### API Endpoints
    | Method | Endpoint | Description |
        |--------|----------|-------------|
    | POST | `/api/focus/:id/connect-nodes` | Create edge between two nodes |
    | DELETE | `/api/focus/:id/disconnect-nodes` | Remove edge between nodes |
    | PUT | `/api/focus/:id/edge/:edgeId` | Update an existing edge |
    | POST | `/api/focus/:id/edges/batch` | Batch edge operations |

    #### Connect Nodes Request
    ```typescript
    interface ConnectNodesRequest {
      sourceNodeId: string;      // Required - Basis ID of source node
      targetNodeId: string;      // Required - Basis ID of target node
      edgeType?: 'animated' | 'default' | 'smartPulseButton'; // Default: 'animated'
      sourceHandle?: string;     // Optional - Handle ID on source node
      targetHandle?: string;     // Optional - Handle ID on target node
      relationship?: {           // Optional - Semantic relationship
        type: 'dependency' | 'sequence' | 'reference' | 'grouping' | 'contrast' | 'derivation';
        direction: 'forward' | 'backward' | 'bidirectional';
        strength?: number;       // 0-1 (default: 1)
        label?: string;
      };
      styling?: {                // Optional - Visual styling
        strokeColor?: string;
        strokeWidth?: number;
        animated?: boolean;
      };
    }
    ```

    #### Connect Nodes Response
    ```typescript
    interface ConnectNodesResponse {
      success: boolean;
      data?: {
        edge: FlowEdge;
        focusId: string;
      };
      error?: string;
    }
    ```

    #### Disconnect Nodes Request
    ```typescript
    interface DisconnectNodesRequest {
      edgeId?: string;           // Option 1: Delete by edge ID
      sourceNodeId?: string;     // Option 2: Delete by source + target
      targetNodeId?: string;     // (both required if using this option)
    }
    ```

    #### React Hook: useConnectNodes
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useConnectNodes() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const connectNodes = useCallback(async (
        focusId: string,
        data: {
          sourceNodeId: string;
          targetNodeId: string;
          relationship?: {
            type: string;
            direction: string;
            strength?: number;
            label?: string;
          };
          edgeType?: string;
        }
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}/connect-nodes`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(data),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to connect nodes');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { connectNodes, loading, error };
    }
    ```

    #### React Hook: useDisconnectNodes
    ```typescript
    export function useDisconnectNodes() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const disconnectNodes = useCallback(async (
        focusId: string,
        data: { edgeId?: string; sourceNodeId?: string; targetNodeId?: string }
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}/disconnect-nodes`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(data),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to disconnect nodes');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { disconnectNodes, loading, error };
    }
    ```

    #### React Flow Integration (onConnect callback)
    ```typescript
    import { useCallback } from 'react';
    import { Connection, useReactFlow } from 'reactflow';

    const { connectNodes, loading } = useConnectNodes();

    const onConnect = useCallback(async (connection: Connection) => {
      if (!connection.source || !connection.target) return;

      try {
        const result = await connectNodes(focusId, {
          sourceNodeId: connection.source,
          targetNodeId: connection.target,
          relationship: {
            type: 'sequence',
            direction: 'forward',
          },
        });

        // Edge is auto-added via socket event or refetch
        console.log('Connected:', result.data.edge);
      } catch (err) {
        console.error('Failed to connect nodes:', err);
      }
    }, [focusId, connectNodes]);
    ```

    #### Socket Events
    | Event | Direction | Payload |
        |-------|-----------|---------|
    | `focus:nodes-connected` | Server → Client | `{ focusId, edge }` |
    | `focus:nodes-disconnected` | Server → Client | `{ focusId, edgeId, sourceNodeId, targetNodeId }` |
    | `focus:edge-updated` | Server → Client | `{ focusId, edge }` |
    | `focus:edges-batch-updated` | Server → Client | `{ focusId, created, deleted, updated }` |

    #### Socket Event Listener
    ```typescript
    useEffect(() => {
      if (!socket) return;

      socket.on('focus:nodes-connected', (data) => {
        // data = { focusId, edge }
        setEdges(prev => [...prev, data.edge]);
      });

      socket.on('focus:nodes-disconnected', (data) => {
        // data = { focusId, edgeId, sourceNodeId, targetNodeId }
        setEdges(prev => prev.filter(e => e.id !== data.edgeId));
      });

      socket.on('focus:edge-updated', (data) => {
        // data = { focusId, edge }
        setEdges(prev => prev.map(e => e.id === data.edge.id ? data.edge : e));
      });

      return () => {
        socket.off('focus:nodes-connected');
        socket.off('focus:nodes-disconnected');
        socket.off('focus:edge-updated');
      };
    }, [socket]);
    ```

    #### Batch Operations Example
    ```typescript
    const batchResult = await fetch(`${API_BASE}/api/focus/${focusId}/edges/batch`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`,
      },
      body: JSON.stringify({
        connect: [
          { sourceNodeId: 'node1', targetNodeId: 'node2' },
          { sourceNodeId: 'node2', targetNodeId: 'node3' },
        ],
        disconnect: [
          { edgeId: 'edge-old1-old2' },
        ],
        update: [
          { edgeId: 'edge-existing', styling: { strokeColor: '#ff0000' } },
        ],
      }),
    });
    ```


- [x] **4.1. Auto-save node position changes**
  - Batch update node positions after drag operations
  - Debounced auto-save to prevent excessive API calls
  - Real-time sync via socket events


- [x] **4.2. Delete Focus and Basis with proper connection severing**
  - Safely delete Basis with all related records (BasisCommit, FocusBasis, RequestBasis, Message references)
  - Safely delete Focus with option to also delete associated Bases
  - Socket events emitted on deletion for real-time UI updates
  - Transaction-based deletion to ensure data integrity

  ### Frontend Implementation Guide: Delete Focus & Basis

  #### API Endpoints
  | Method | Endpoint | Description |
      |--------|----------|-------------|
  | DELETE | `/api/basis/:id` | Delete a Basis and sever all connections |
  | DELETE | `/api/focus/:id` | Delete a Focus (preserves Bases by default) |
  | DELETE | `/api/focus/:id?deleteBases=true` | Delete Focus AND all its Bases |

  #### Delete Basis Response
    ```typescript
    interface DeleteBasisResponse {
      success: boolean;
      data?: {
        message: string;
        deletedBasis: {
          id: string;
          title: string;
          entityType: string;
          atlasId: string | null;
          pathId: string | null;
        };
        severedConnections: {
          commits: number;        // BasisCommit records deleted
          focusBases: number;     // FocusBasis junction records deleted
          requestBases: number;   // RequestBasis junction records deleted
          messagesUpdated: number; // Messages with reference set to null
        };
      };
      error?: string;
    }
    ```

  #### Delete Focus Response
    ```typescript
    interface DeleteFocusResponse {
      success: boolean;
      data?: {
        message: string;
        deletedFocus: {
          id: string;
          title: string;
        };
        severedConnections: {
          commits: number;
          focusBases: number;
          requests: number;
          requestBases: number;
          contexts: number;
        };
        // Only present if deleteBases=true
        deletedBases?: {
          count: number;
          basisCommits: number;
          basisRequestBases: number;
          messagesUpdated: number;
        };
      };
      error?: string;
    }
    ```

  #### React Hook: useDeleteBasis
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useDeleteBasis() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const deleteBasis = useCallback(async (basisId: string) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/basis/${basisId}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to delete basis');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { deleteBasis, loading, error };
    }
    ```

  #### React Hook: useDeleteFocus
    ```typescript
    export function useDeleteFocus() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const deleteFocus = useCallback(async (
        focusId: string,
        options: { deleteBases?: boolean } = {}
      ) => {
        setLoading(true);
        setError(null);

        try {
          const url = options.deleteBases
            ? `${API_BASE}/api/focus/${focusId}?deleteBases=true`
            : `${API_BASE}/api/focus/${focusId}`;

          const response = await fetch(url, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to delete focus');
          }

          return result;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Unknown error';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { deleteFocus, loading, error };
    }
    ```

  #### Socket Events
  | Event | Direction | Payload |
      |-------|-----------|---------|
  | `basis:deleted` | Server → Client | `{ basisId, severedConnections }` |
  | `focus:deleted` | Server → Client | `{ focusId, deletedBases }` |

  #### Socket Event Listener
    ```typescript
    useEffect(() => {
      if (!socket) return;

      socket.on('basis:deleted', (data) => {
        // Remove basis from local state
        setBases(prev => prev.filter(b => b.id !== data.basisId));
        // Also remove from any focus that contained it
        setNodes(prev => prev.filter(n => n.id !== data.basisId));
      });

      socket.on('focus:deleted', (data) => {
        // Remove focus from local state
        setFocuses(prev => prev.filter(f => f.id !== data.focusId));
        // Navigate away if viewing deleted focus
        if (currentFocusId === data.focusId) {
          router.push('/focuses');
        }
      });

      return () => {
        socket.off('basis:deleted');
        socket.off('focus:deleted');
      };
    }, [socket]);
    ```

- [ ] **5. Start chat from focus**
  - Open chat drawer from Focus context
  - Pre-populate chat with Focus information
  - Stream AI responses

- [ ] **6. Start chat from node**
  - Open chat drawer when clicking a node
  - Include node data as context for the chat
  - Allow node refinement through conversation

- [ ] **7. Refine request processing in back end**
  - Improve request handling logic
  - Add better error handling
  - Optimize response generation

- [ ] **8. Web request**
  - Implement web search/fetch functionality
  - Parse and display web results as Basis objects

- [ ] **9. Voice request**
  - Enable voice input for requests
  - Transcribe and process voice commands

- [ ] **10. Focus API** *(Backend)*
  - Build Focus CRUD endpoints
  - Handle Focus state management

- [ ] **11. Focus socket** *(Backend)*
  - Implement WebSocket for real-time Focus updates
  - Handle live collaboration events

- [ ] **12. Focus AI** *(Backend)*
  - AI processing pipeline for Focus requests
  - Generate and refine Basis objects

- [ ] **13. Search objects**
  - Implement search across Focus/Basis/Result objects
  - Add filtering and sorting capabilities

- [ ] **14. Simplify and Refine**
  - Clean up codebase and remove redundancy
  - Optimize performance and UX flows

- [ ] **15. Live Brainstorming (Auto Request Chunking and AI Fulfillment)**
  - Auto-chunk complex requests into sub-tasks
  - Real-time AI fulfillment as user types/speaks

- [ ] **16. Begin Lens Integration**
  - Connect Lens data sources
  - Map Lens entities to Focus/Basis structures

