# To-Do List - December 24, 2024

## V3 Interface Tasks

- [ ] **1. Make functional create new focus left drawer**
  - Implement the drawer UI for creating a new Focus
  - Connect to Focus creation API
  - Update context state when Focus is created

- [ ] **2. Add node to interface**
  - Enable adding nodes to the React Flow canvas
  - Connect node creation to Interface state
  - Persist node data to backend

- [ ] **2.5. Add List and Search for Focuses and Bases**
  - Enable listing user's Focuses and Bases via socket events
  - Implement search across Focuses and Bases
  - Socket events: `user:list-focuses`, `user:list-bases`, `user:search`
  - REST endpoints: `GET /api/basis`, `GET /api/basis/user/:userId`, `GET /api/basis/search`


- [ ] **2.6. Load Focus by ID**
  - Load a Focus with full details for the interface
  - Fetch bases and interface data
  - Will add more customization later

  ### Frontend Implementation Guide: Load Focus by ID

  #### API Endpoints
  | Method | Endpoint | Description |
      |--------|----------|-------------|
  | GET | `/api/focus/:id` | Get focus with bases |
  | GET | `/api/focus/:id/interface` | Get focus interface JSON |
  | GET | `/api/focus/:id/bases` | Get all bases in focus |

  #### Response: GET /api/focus/:id
    ```typescript
    interface GetFocusResponse {
      success: boolean;
      data?: {
        id: string;
        title: string;
        description: string | null;
        imageUrl: string | null;
        metadata: object | null;
        interface: object | null;  // React Flow nodes/edges
        createdAt: Date | string;
        updatedAt: Date | string;
        userId: string;
        atlasId: string | null;
        pathId: string | null;
        user: { id: string; name: string; email: string };
        bases: Array<{
          id: string;
          focusId: string;
          basisId: string;
          position: { x: number; y: number } | null;
          basis: {
            id: string;
            title: string;
            description: string | null;
            entityType: string;
            metadata: object;
            sourceEntityId: string | null;
          };
        }>;
      };
      error?: string;
    }
    ```

  #### Response: GET /api/focus/:id/interface
    ```typescript
    interface FocusInterface {
      goal: {
        id: string;
        name: string;
        description: string;
        icon?: string;
      };
      nodes: Array<{
        id: string;
        type: string;
        position: { x: number; y: number };
        data: {
          label: string;
          description?: string;
          entityType: string;
          basisId: string;
        };
      }>;
      edges: Array<{
        id: string;
        source: string;
        target: string;
        type?: string;
      }>;
    }
    ```

  #### React Hook: useFocus
    ```typescript
    import { useState, useEffect, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    interface FocusData {
      focus: GetFocusResponse['data'];
      interface: FocusInterface | null;
    }

    export function useFocus(focusId: string | null) {
      const [data, setData] = useState<FocusData | null>(null);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const loadFocus = useCallback(async () => {
        if (!focusId) return;

        setLoading(true);
        setError(null);

        try {
          // Fetch focus and interface in parallel
          const [focusRes, interfaceRes] = await Promise.all([
            fetch(`${API_BASE}/api/focus/${focusId}`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
            fetch(`${API_BASE}/api/focus/${focusId}/interface`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`,
              },
            }),
          ]);

          const focusData = await focusRes.json();
          const interfaceData = await interfaceRes.json();

          if (!focusData.success) {
            throw new Error(focusData.error || 'Failed to load focus');
          }

          setData({
            focus: focusData.data,
            interface: interfaceData.success ? interfaceData.data : null,
          });
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to load focus');
        } finally {
          setLoading(false);
        }
      }, [focusId]);

      useEffect(() => {
        loadFocus();
      }, [loadFocus]);

      return { data, loading, error, refetch: loadFocus };
    }
    ```

- [ ] **2.7. Edit Focus Details & Metadata**
  - Allow editing focus title, description, metadata
  - Update focus via API
  - Optimistic updates with rollback on error

  ### Frontend Implementation Guide: Edit Focus

  #### API Endpoint
    ```
    PUT /api/focus/:id
    ```

  #### Request Body
    ```typescript
    interface UpdateFocusRequest {
      title?: string;
      description?: string;
      imageUrl?: string;
      metadata?: object;
      interface?: object;  // React Flow nodes/edges
    }
    ```

  #### Response
    ```typescript
    interface UpdateFocusResponse {
      success: boolean;
      data?: Focus;
      error?: string;
    }
    ```

  #### React Hook: useUpdateFocus
    ```typescript
    import { useState, useCallback } from 'react';

    const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

    export function useUpdateFocus() {
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const updateFocus = useCallback(async (
        focusId: string,
        updates: UpdateFocusRequest
      ) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`${API_BASE}/api/focus/${focusId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('token')}`,
            },
            body: JSON.stringify(updates),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || 'Failed to update focus');
          }

          return result.data;
        } catch (err) {
          const message = err instanceof Error ? err.message : 'Update failed';
          setError(message);
          throw err;
        } finally {
          setLoading(false);
        }
      }, []);

      return { updateFocus, loading, error };
    }
    ```

  #### Inline Edit with Optimistic Update
    ```typescript
    const handleTitleBlur = async (newTitle: string) => {
      if (newTitle === focus.title) return;

      // Optimistic update
      const previousTitle = focus.title;
      setFocus(prev => ({ ...prev, title: newTitle }));

      try {
        await updateFocus(focus.id, { title: newTitle });
      } catch (err) {
        // Rollback on error
        setFocus(prev => ({ ...prev, title: previousTitle }));
      }
    };
    ```

- [ ] **3. Make request to focus AI (create object)**
  - Wire up the request submission flow
  - Create Basis/Result objects from AI responses
  - Display results in the interface

- [ ] **4. Connect node**
  - Implement edge creation between nodes
  - Save edge connections to Interface state
  - Handle connection validation

- [ ] **5. Start chat from focus**
  - Open chat drawer from Focus context
  - Pre-populate chat with Focus information
  - Stream AI responses

- [ ] **6. Start chat from node**
  - Open chat drawer when clicking a node
  - Include node data as context for the chat
  - Allow node refinement through conversation

- [ ] **7. Refine request processing in back end**
  - Improve request handling logic
  - Add better error handling
  - Optimize response generation

- [ ] **8. Web request**
  - Implement web search/fetch functionality
  - Parse and display web results as Basis objects

- [ ] **9. Voice request**
  - Enable voice input for requests
  - Transcribe and process voice commands

- [ ] **10. Focus API** *(Backend)*
  - Build Focus CRUD endpoints
  - Handle Focus state management

- [ ] **11. Focus socket** *(Backend)*
  - Implement WebSocket for real-time Focus updates
  - Handle live collaboration events

- [ ] **12. Focus AI** *(Backend)*
  - AI processing pipeline for Focus requests
  - Generate and refine Basis objects

- [ ] **13. Search objects**
  - Implement search across Focus/Basis/Result objects
  - Add filtering and sorting capabilities

- [ ] **14. Simplify and Refine**
  - Clean up codebase and remove redundancy
  - Optimize performance and UX flows

- [ ] **15. Live Brainstorming (Auto Request Chunking and AI Fulfillment)**
  - Auto-chunk complex requests into sub-tasks
  - Real-time AI fulfillment as user types/speaks

- [ ] **16. Begin Lens Integration**
  - Connect Lens data sources
  - Map Lens entities to Focus/Basis structures

